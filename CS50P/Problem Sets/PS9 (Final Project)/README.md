# NFL Player Statistics
#### Video Demo: https://youtu.be/wYkFkxn-SdI
#### Description:
The **purpose** of this project was to both explore and better understand API retrieval as well as offer an interactive command-line searching service for NFL players' information and statistics. 

The program employs the _requests_ library as its API retrieval device. The _json_ library was used during construction to reformat JSON output but was not necessary for the final output. A json.dumps() function is included but commented out as it is useful to understand the json output and would be useful during any further modifications and bug testing. Similarly, the _json_ library was decided to remain imported, albeit not used, as it is useful for further improvement and bug testing. The _datetime_ library is used briefly in the get_injury() function to reformat a date in a cleaner, more coherent format.

The program is structured with a **main** function that only serves to construct the framework for the interactive functionality. The main function calls four functions where most of the functionality takes place: get_playerinfo(), get_stats(), get_bio(), and get_injury(). First, the main function calls get_playerinfo() to prompt the user for a player, utilizing various extra requests and filters to isolate the desired player if necessary and retrieve the player information. That player information is then called into get_bio() which displays a cleanly formatted biography of the player. Immediately after, the main function calls get_injury() on the player information to (cleanly) display any injury information about the player. Subsequently, the main function calls get_stats() on the player information which asks the user which statistics it would like to see and displays them in an organized, clear, and comprehensible fashion. The user may use the get_stats() functionality for their selected player until they desire to EXIT (by inputting EXIT). The main function then asks if the user would like to research another player. If yes is inputted, the program will re-run the main function again starting with get_playerinfo() to obtain the new player of interest. If "No" (or anything but "yes", "y", "ok", "okay", or "sure") is inputted, the user is met with a thank you message: "I hope you enjoyed! Try again soon..."

The **get_player()** seems long and complicated, but the general logic in it is quite simple. In all honesty, the edge cases are the main complexity and length contributor to the function. 
To begin, the URL and headers for the API retrieval are defined to prevent redundant and long replications. There are two paths in the function; the user begins on path 1. Path 1 begins with a user prompt: "Player: ". The difference between path 1 and path 2 is path 2 skips over this "Player: " prompt since (if applicable) the user is prompted later with "Which one? " after being given a list of player's names that contain the input. If the original input/name is a _unique_ name (or associated with a _unique_ name eg. last name), the function outputs the player's info from the API. To note, the player's info contains everything from biographical, injury, and statistical data. If the original input/name is not associated with any players, the user is re-prompted: "Player: ". If the original input/name is associated with/contained in multiple player's names, a list of associated players with their team is printed--"PLAYER (TEAM)"--and the user is prompted with "Which one? ". If the subsequent input/name is a _unique_ player name, the function outputs the player's info from the API. Otherwise, the function reprints a list of names associated with the new input. To note, when prompted "Which one? ", the user may input any new input completely different from the displayed list or previous input. However, if the user's input is not associated with any name, the player is notified that "[Their input] not found, please try again." and re-prompted on path 1 with "Player: ". 
Now following along the path further to catch certain edge cases, if all the names in the associated player list are the _same_ (exactly identical) or _similar_ (all but one name is contained within another), the user is prompted with "Which team? (use abbreviation) " where they must now input the team (abbreviation) associated to their player of interest. If the input is not one of the listed player's teams, the user is notified to "Please choose a valid team among the player's teams listed." and simply re-prompted. Once a valid team is inputted, the function outputs the player's info associated with that team.
Moving on to another edge case, if the player search input (either during the path 1 or path 2 player name prompts) results in a list of players with the _same_ or _similar_ names but with at least two players with the _same_ team, the user is displayed a list of the player's position and schools (in order of the original list) and prompted with "Which position (abbreviation) or school? ". Here, the user should input the position (abbreviation) or school of their player of interest. As with the team specification prompt, if the user inputs an invalid position or school, they are notified to "Try again! Input only (1) position or school and ensure spelling is correct. Position input should be an abbreviation. Input the school if the same position." and re-prompted. Once a valid position (abbreviation) or school is inputted, the function outputs the player's info.
As of now, there is no support for if players have the _same_ or _similar_ names, the _same_ team, the _same_ position, and the _same_ school as it is highly unlikely.

The **get_stats()** function is much less complex than the get_player() function and is the heart of the interaction of the program. It takes one required argument--info--which is player info formatted in a dictionary based on the API's format. This info is retrieved in the get_player() function.
Immediately, if the player has _no_ stats for the current season, the function outputs "No stats exist for this player this season." More commonly, if the player does have stats for the current season, the user is prompted with "Rushing|Passing|Receiving|Defense|EXIT: "; in other words, the user is prompted with a menu-like list of valid inputs. If "Rushing", "Passing", "Receiving" or "Defense" is inputted, the player's respective statistics in that category will display (in a clean format) and the user will be re-prompted with the same menu. For a "Rushing" input, the player's "Rushing yards", "Carries", and "Rushing TDs" are displayed. For a "Passing" input, the player's "Pass Attempts", "Pass Completions", "Passing Yards", "Passing TDs", and "Interceptions" are displayed. For a "Receiving" input, the player's "Targets", "Receptions", "Receiving Yards", and "Receiving TDs" are displayed. For a "Defense" input, the player's "Total Tackles", "Solo Tackles", "Tackles for Loss (TFL)", "Sacks", "QB Hits", "Pass Deflections", "Defensive Interceptions", and "Defensive TDs" are displayed. If the user inputs an invalid input (one not listed in the menu), the user will be notified "Invalid input." and re-prompted with the menu. If the user inputs "Exit" (as well as "Quit", "End", "No", or "Done"), the function will simply output "[Player's name] Stats.". 
To summarize, this function acts as an interactive menu and query for player statistics given in the API's dictionary format and outputted in a clear and comprehensible reformat.

The **get_bio()** function is very simple and has no interactive functionality.
Like get_stats(), this function takes one argument--info--which is player info formatted in a dictionary based on the API's format, and outputs a clear and comprehensible reformat of the player's biographical information. This information being: team, jersey number, age, date of birth in MM/DD/YYYY format, height in ft & in (HT), weight in lbs (WT), position (abbreviation), season number/experience, and school.
In essence, this function is simply a reformatter of the player's biological info retrieved from the API. 

The **get_injury()** function is also very simple and has no interactive functionality.
Similarly, the function takes one argument--info--which is player info formatted in a dictionary based on the API's format. If the player has no injury designation, the function outputs "No injury designation". Otherwise, if the player has an injury designation, the function outputs the player's "Designation", "Injury Date", and "Description" in a clear and coherent format. The function utilizes the datetime library to convert "Injury Date" into a cleaner format.

A helper function **similar_names()** was defined to help filter for _similar_ names when isolating a player of interest in get_playerinfo(). The function takes one argument: names--a list of strings/names. If all but one substring/name in the list are substrings of another, the function outputs True. Otherwise, the function outputs false. This is useful based on how the search operates using the chosen API.

#### test_project.py Usage & Updates
The unit test file for this program is not ordinary. It must be amended to the current NFL game environment and developments. Review all players and player information listed in each case and ensure they all are still valid. Cases include many edge cases such as players with no current season stats, common names, common teams and names, etc. _If any cases are invalid, modify the name accordingly._ Be cautious of spelling errors as they may lead to false failures. If no player falls under the category, it is suitable to replace the string with None. The tests are coded to ignore tests associated with a given case if the player name is assigned None. Do not forget to modify any extra information in the given case (eg. common expression, school, position, etc.). A space in the prior comments is offered to keep track of the UPDATE date. **ONLY modify the first section of names**
The test file employs _pytest_ as its unit testing framework. It utilizes monkeypatch and captured functionalities to set inputs and record outputs for testing. Both are used frequently throughout the tests. The test file also employs _requests_ to retrieve API information and ensure the outputs from project.py match up with the API.
As a lot of edge cases occur in the get_playerinfo() function, the bulk of the testing involves these edge cases. In fact, _six_ different cases are tested in separate test functions on the get_playerinfo() to ensure these edge cases are monitored and identify which, if any, fail.
While test_project.py is long, it is an attempt to be fairly comprehensive and an effort to catch potential errors from future edits.